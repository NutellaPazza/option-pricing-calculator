"""
Main Streamlit application for Option Pricing Calculator.
Entry point for the web application.
"""

import streamlit as st
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from models.black_scholes import BlackScholesModel
from models.monte_carlo import MonteCarloModel
from models.binomial_tree import BinomialTreeModel
from calculations.greeks import GreeksCalculator
from ui.sidebar import render_sidebar, render_sidebar_footer
from ui.results import (
    display_option_price,
    display_greeks,
    display_input_summary,
    display_payoff_info,
    display_time_value
)
from ui.charts import (
    plot_payoff_diagram,
    plot_greeks_vs_spot,
    plot_price_vs_volatility,
    plot_price_vs_time,
    plot_all_greeks
)
from ui.heatmaps import OptionHeatmaps
from ui.helpers import (
    show_calculation_time,
    show_performance_metrics,
    show_calculation_settings,
    show_convergence_indicator,
    create_greek_explanation_card
)
from ui.export import create_download_section
from config.settings import APP_INFO


# Page configuration
st.set_page_config(
    page_title=APP_INFO['title'],
    page_icon=APP_INFO['icon'],
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'mailto:giovanni.destasio@example.com',
        'Report a bug': 'mailto:giovanni.destasio@example.com',
        'About': f"{APP_INFO['title']} v{APP_INFO['version']} - {APP_INFO['description']}"
    }
)


def main():
    """Main application function."""
    
    # Header
    st.title(f"{APP_INFO['icon']} {APP_INFO['title']}")
    st.markdown(f"*{APP_INFO['description']}*")
    st.markdown("---")
    
    # Render sidebar and get parameters
    params = render_sidebar()
    render_sidebar_footer()
    
    # Initialize models
    bs_model = BlackScholesModel()
    greeks_calc = GreeksCalculator()
    
    # Create tabs
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
        "üî¢ Pricing & Results",
        "üìà Greeks Analysis",
        "ÔøΩ Sensitivity Analysis",
        "ÔøΩ Heatmaps",
        "‚ÑπÔ∏è About"
    ])
    
    # TAB 1: Pricing & Results
    with tab1:
        st.header("Option Pricing Results")
        
        # Display input summary
        display_input_summary(params)
        
        st.markdown("---")
        
        # Calculate price based on selected model
        try:
            if params['model'] == "Black-Scholes":
                # Calculate price with timing
                with st.spinner("‚ö° Calculating option price..."):
                    price, calc_time_ms = show_calculation_time(
                        bs_model.calculate_price,
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type']
                    )
                
                # Display price
                display_option_price(price, params['option_type'], "Black-Scholes")
                
                # Show performance metrics
                show_performance_metrics(calc_time_ms, "Black-Scholes")
                
                # Calculate and display Greeks
                st.markdown("---")
                greeks = greeks_calc.calculate_all_greeks(
                    spot=params['spot'],
                    strike=params['strike'],
                    time_to_maturity=params['time_to_maturity'],
                    risk_free_rate=params['risk_free_rate'],
                    volatility=params['volatility'],
                    option_type=params['option_type']
                )
                display_greeks(greeks)
                
                # Export section
                create_download_section(params, price, greeks, "Black-Scholes")
                
                # Calculate intrinsic value
                st.markdown("---")
                if params['option_type'] == 'call':
                    intrinsic_value = max(params['spot'] - params['strike'], 0)
                else:
                    intrinsic_value = max(params['strike'] - params['spot'], 0)
                
                display_time_value(price, intrinsic_value)
                
                # Payoff diagram
                st.markdown("---")
                st.subheader("üìâ Payoff Diagram")
                plot_payoff_diagram(
                    spot=params['spot'],
                    strike=params['strike'],
                    option_price=price,
                    option_type=params['option_type']
                )
                
            elif params['model'] == "Monte Carlo":
                # Initialize Monte Carlo model
                mc_model = MonteCarloModel(
                    num_simulations=100000,
                    num_steps=252,
                    seed=42,
                    antithetic=True
                )
                
                st.info("üé≤ **Monte Carlo Simulation** - Using 100,000 simulations with antithetic variates for variance reduction")
                
                # Show calculation settings
                show_calculation_settings("Monte Carlo")
                
                # Calculate price with progress and timing
                with st.spinner("‚ö° Running Monte Carlo simulation (100K paths)..."):
                    price, calc_time_ms = show_calculation_time(
                        mc_model.calculate_price,
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type']
                    )
                
                # Display price
                display_option_price(price, params['option_type'], "Monte Carlo")
                
                # Show confidence interval
                st.markdown("---")
                st.subheader("üìä Statistical Analysis")
                
                with st.spinner("Calculating confidence interval..."):
                    conf_result = mc_model.calculate_price_with_confidence(
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type'],
                        confidence_level=0.95
                    )
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric(
                        "Standard Error",
                        f"${conf_result['std_error']:.6f}",
                        help="Statistical uncertainty in the estimate"
                    )
                
                with col2:
                    st.metric(
                        "Lower Bound (95%)",
                        f"${conf_result['lower_bound']:.6f}"
                    )
                
                with col3:
                    st.metric(
                        "Upper Bound (95%)",
                        f"${conf_result['upper_bound']:.6f}"
                    )
                
                st.info(f"üí° The true option price has a 95% probability of being between ${conf_result['lower_bound']:.4f} and ${conf_result['upper_bound']:.4f}")
                
                # Compare with Black-Scholes
                st.markdown("---")
                st.subheader("üìê Comparison with Black-Scholes")
                
                bs_price = bs_model.calculate_price(
                    spot=params['spot'],
                    strike=params['strike'],
                    time_to_maturity=params['time_to_maturity'],
                    risk_free_rate=params['risk_free_rate'],
                    volatility=params['volatility'],
                    option_type=params['option_type']
                )
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("Monte Carlo", f"${price:.6f}")
                
                with col2:
                    st.metric("Black-Scholes", f"${bs_price:.6f}")
                
                with col3:
                    diff = abs(price - bs_price)
                    diff_pct = (diff / bs_price) * 100
                    st.metric("Difference", f"${diff:.6f}", f"{diff_pct:.2f}%")
                
                if diff_pct < 1.0:
                    st.success("‚úÖ Excellent agreement with analytical solution!")
                elif diff_pct < 2.0:
                    st.info("‚úì Good agreement with analytical solution")
                else:
                    st.warning("‚ö†Ô∏è Consider increasing number of simulations for better accuracy")
                
                # Show performance metrics
                show_performance_metrics(calc_time_ms, "Monte Carlo")
                
                # Calculate and display Greeks (using numerical methods)
                st.markdown("---")
                greeks = greeks_calc.calculate_all_greeks(
                    spot=params['spot'],
                    strike=params['strike'],
                    time_to_maturity=params['time_to_maturity'],
                    risk_free_rate=params['risk_free_rate'],
                    volatility=params['volatility'],
                    option_type=params['option_type']
                )
                display_greeks(greeks)
                
                # Export section
                create_download_section(params, price, greeks, "Monte Carlo")
                
                # Model info
                st.markdown("---")
                with st.expander("‚ÑπÔ∏è Monte Carlo Model Information"):
                    model_info = mc_model.get_model_info()
                    st.markdown(f"**{model_info['name']}**")
                    st.markdown(model_info['description'])
                    
                    st.markdown("**Parameters:**")
                    for key, value in model_info['parameters'].items():
                        st.write(f"- {key}: {value}")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.markdown("**Advantages:**")
                        for adv in model_info['advantages']:
                            st.write(f"‚úì {adv}")
                    
                    with col2:
                        st.markdown("**Disadvantages:**")
                        for dis in model_info['disadvantages']:
                            st.write(f"‚úó {dis}")
                
                # Payoff diagram
                st.markdown("---")
                st.subheader("üìâ Payoff Diagram")
                plot_payoff_diagram(
                    spot=params['spot'],
                    strike=params['strike'],
                    option_price=price,
                    option_type=params['option_type']
                )
                
            elif params['model'] == "Binomial Tree":
                # Initialize Binomial Tree model
                # Check if American option is selected (we'll add this option later)
                is_american = st.checkbox(
                    "American Option (Early Exercise)",
                    value=False,
                    help="European options can only be exercised at expiration. American options can be exercised anytime before expiration."
                )
                
                num_steps = st.slider(
                    "Number of Tree Steps",
                    min_value=10,
                    max_value=500,
                    value=100,
                    step=10,
                    help="More steps = more accurate but slower. 100-200 steps is usually sufficient."
                )
                
                bt_model = BinomialTreeModel(
                    num_steps=num_steps,
                    american=is_american
                )
                
                option_style = "American" if is_american else "European"
                st.info(f"üå≤ **Binomial Tree (Cox-Ross-Rubinstein)** - {num_steps} steps, {option_style} option")
                
                # Show calculation settings
                show_calculation_settings("Binomial Tree")
                
                # Calculate price with progress and timing
                with st.spinner(f"‚ö° Building binomial tree ({num_steps} steps)..."):
                    price, calc_time_ms = show_calculation_time(
                        bt_model.calculate_price,
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type']
                    )
                
                # Store in session state for other tabs
                st.session_state['bt_is_american'] = is_american
                st.session_state['bt_steps'] = num_steps
                
                # Display price
                display_option_price(price, params['option_type'], f"Binomial Tree ({option_style})")
                
                # Compare with Black-Scholes
                st.markdown("---")
                st.subheader("ÔøΩ Comparison with Black-Scholes")
                
                bs_price = bs_model.calculate_price(
                    spot=params['spot'],
                    strike=params['strike'],
                    time_to_maturity=params['time_to_maturity'],
                    risk_free_rate=params['risk_free_rate'],
                    volatility=params['volatility'],
                    option_type=params['option_type']
                )
                
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Binomial Tree", f"${price:.6f}")
                
                with col2:
                    st.metric("Black-Scholes", f"${bs_price:.6f}")
                
                with col3:
                    diff = abs(price - bs_price)
                    diff_pct = (diff / bs_price) * 100
                    st.metric("Difference", f"${diff:.6f}", f"{diff_pct:.2f}%")
                
                with col4:
                    if is_american:
                        # Calculate European BT for comparison
                        bt_euro = BinomialTreeModel(num_steps=num_steps, american=False)
                        euro_price = bt_euro.calculate_price(
                            spot=params['spot'],
                            strike=params['strike'],
                            time_to_maturity=params['time_to_maturity'],
                            risk_free_rate=params['risk_free_rate'],
                            volatility=params['volatility'],
                            option_type=params['option_type']
                        )
                        early_premium = price - euro_price
                        st.metric(
                            "Early Exercise Premium",
                            f"${early_premium:.6f}",
                            help="Additional value from early exercise right"
                        )
                
                # Show convergence indicator
                show_convergence_indicator(diff_pct, threshold=2.0)
                
                # Show performance metrics
                show_performance_metrics(calc_time_ms, f"Binomial Tree ({num_steps} steps)")
                
                # Show early exercise info for American options
                if is_american and params['option_type'] == 'put':
                    st.info("üí° **American Puts** often have early exercise value, especially when deep in-the-money or with high interest rates.")
                
                # Calculate and display Greeks
                st.markdown("---")
                greeks = greeks_calc.calculate_all_greeks(
                    spot=params['spot'],
                    strike=params['strike'],
                    time_to_maturity=params['time_to_maturity'],
                    risk_free_rate=params['risk_free_rate'],
                    volatility=params['volatility'],
                    option_type=params['option_type']
                )
                display_greeks(greeks)
                
                # Export section
                create_download_section(params, price, greeks, f"Binomial Tree ({option_style})")
                
                # Convergence Analysis
                st.markdown("---")
                st.subheader("üìä Convergence Analysis")
                
                with st.spinner("Analyzing convergence..."):
                    convergence = bt_model.get_convergence_analysis(
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type'],
                        step_sizes=[10, 25, 50, 100, 200]
                    )
                
                # Create convergence chart
                import plotly.graph_objects as go
                
                fig = go.Figure()
                
                fig.add_trace(go.Scatter(
                    x=convergence['step_sizes'],
                    y=convergence['prices'],
                    mode='lines+markers',
                    name='Binomial Tree',
                    line=dict(color='blue', width=2),
                    marker=dict(size=8)
                ))
                
                fig.add_hline(
                    y=bs_price,
                    line_dash="dash",
                    line_color="red",
                    annotation_text=f"Black-Scholes: ${bs_price:.4f}",
                    annotation_position="right"
                )
                
                fig.update_layout(
                    title="Convergence: Binomial Tree ‚Üí Black-Scholes",
                    xaxis_title="Number of Steps",
                    yaxis_title="Option Price ($)",
                    hovermode='x unified',
                    height=400
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                st.info("üí° **Convergence**: As steps increase, Binomial Tree converges to Black-Scholes solution. Oscillation is normal.")
                
                # Model info
                st.markdown("---")
                with st.expander("‚ÑπÔ∏è Binomial Tree Model Information"):
                    model_info = bt_model.get_model_info()
                    st.markdown(f"**{model_info['name']}**")
                    st.markdown(model_info['description'])
                    
                    st.markdown("**Parameters:**")
                    for key, value in model_info['parameters'].items():
                        st.write(f"- {key}: {value}")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.markdown("**Advantages:**")
                        for adv in model_info['advantages']:
                            st.write(f"‚úì {adv}")
                    
                    with col2:
                        st.markdown("**Disadvantages:**")
                        for dis in model_info['disadvantages']:
                            st.write(f"‚úó {dis}")
                
                # Payoff diagram
                st.markdown("---")
                st.subheader("üìâ Payoff Diagram")
                plot_payoff_diagram(
                    spot=params['spot'],
                    strike=params['strike'],
                    option_price=price,
                    option_type=params['option_type']
                )
                
        except Exception as e:
            st.error(f"‚ùå Error calculating option price: {str(e)}")
            st.exception(e)
    
    # TAB 2: Greeks Analysis
    with tab2:
        st.header("Greeks Sensitivity Analysis")
        
        if params['model'] == "Black-Scholes":
            # Display current Greeks
            greeks = greeks_calc.calculate_all_greeks(
                spot=params['spot'],
                strike=params['strike'],
                time_to_maturity=params['time_to_maturity'],
                risk_free_rate=params['risk_free_rate'],
                volatility=params['volatility'],
                option_type=params['option_type']
            )
            
            st.markdown("### Current Greeks Values")
            display_greeks(greeks)
            
            st.markdown("---")
            
            # Plot all Greeks together
            st.markdown("### Greeks vs Spot Price")
            plot_all_greeks(params, greeks_calc)
            
            st.markdown("---")
            
            # Individual Greek plots
            st.markdown("### Individual Greek Analysis")
            
            greek_choice = st.selectbox(
                "Select Greek to Analyze",
                options=['Delta', 'Gamma', 'Theta', 'Vega', 'Rho'],
                index=0
            )
            
            # Map Greek names to calculator methods
            greek_methods = {
                'Delta': greeks_calc.delta,
                'Gamma': greeks_calc.gamma,
                'Theta': greeks_calc.theta,
                'Vega': greeks_calc.vega,
                'Rho': greeks_calc.rho
            }
            
            plot_greeks_vs_spot(
                params=params,
                greek_calculator=greek_methods[greek_choice],
                greek_name=greek_choice
            )
            
            # Greek interpretation
            interpretations = {
                'Delta': """
                **Delta (Œî)** measures the rate of change of option value with respect to changes in the underlying asset's price.
                - **Call Delta**: Ranges from 0 to 1
                - **Put Delta**: Ranges from -1 to 0
                - Also represents the hedge ratio (number of shares to hedge)
                """,
                'Gamma': """
                **Gamma (Œì)** measures the rate of change in Delta with respect to changes in the underlying price.
                - Maximum for at-the-money options
                - Indicates Delta stability
                - Same for calls and puts
                - Always positive for long positions
                """,
                'Theta': """
                **Theta (Œò)** measures the rate of change in option value with respect to time (time decay).
                - Usually negative for long positions
                - Expressed per day
                - Maximum for at-the-money options near expiration
                - Time is the enemy of option buyers
                """,
                'Vega': """
                **Vega (ŒΩ)** measures sensitivity to volatility changes.
                - Always positive for long positions
                - Same for calls and puts
                - Maximum for at-the-money options
                - Long-dated options have higher vega
                """,
                'Rho': """
                **Rho (œÅ)** measures sensitivity to interest rate changes.
                - Positive for calls, negative for puts
                - Less significant for short-dated options
                - More important for long-dated options
                """
            }
            
            with st.expander(f"‚ÑπÔ∏è About {greek_choice}"):
                st.markdown(interpretations[greek_choice])
        
        elif params['model'] == "Monte Carlo":
            st.info("üìä **Note:** Greeks for Monte Carlo are calculated using numerical approximation methods (finite differences)")
            
            # Display current Greeks
            greeks = greeks_calc.calculate_all_greeks(
                spot=params['spot'],
                strike=params['strike'],
                time_to_maturity=params['time_to_maturity'],
                risk_free_rate=params['risk_free_rate'],
                volatility=params['volatility'],
                option_type=params['option_type']
            )
            
            st.markdown("### Current Greeks Values")
            display_greeks(greeks)
            
            st.markdown("---")
            
            # Plot all Greeks together
            st.markdown("### Greeks vs Spot Price")
            plot_all_greeks(params, greeks_calc)
            
            st.markdown("---")
            
            # Individual Greek plots
            st.markdown("### Individual Greek Analysis")
            
            greek_choice = st.selectbox(
                "Select Greek to Analyze",
                options=['Delta', 'Gamma', 'Theta', 'Vega', 'Rho'],
                index=0,
                key="mc_greek_choice"
            )
            
            # Map Greek names to calculator methods
            greek_methods = {
                'Delta': greeks_calc.delta,
                'Gamma': greeks_calc.gamma,
                'Theta': greeks_calc.theta,
                'Vega': greeks_calc.vega,
                'Rho': greeks_calc.rho
            }
            
            plot_greeks_vs_spot(
                params=params,
                greek_calculator=greek_methods[greek_choice],
                greek_name=greek_choice
            )
            
            # Greek interpretation
            interpretations = {
                'Delta': """
                **Delta (Œî)** measures the rate of change of option value with respect to changes in the underlying asset's price.
                - **Call Delta**: Ranges from 0 to 1
                - **Put Delta**: Ranges from -1 to 0
                - Also represents the hedge ratio (number of shares to hedge)
                """,
                'Gamma': """
                **Gamma (Œì)** measures the rate of change in Delta with respect to changes in the underlying price.
                - Maximum for at-the-money options
                - Indicates Delta stability
                - Same for calls and puts
                - Always positive for long positions
                """,
                'Theta': """
                **Theta (Œò)** measures the rate of change in option value with respect to time (time decay).
                - Usually negative for long positions
                - Expressed per day
                - Maximum for at-the-money options near expiration
                - Time is the enemy of option buyers
                """,
                'Vega': """
                **Vega (ŒΩ)** measures sensitivity to volatility changes.
                - Always positive for long positions
                - Same for calls and puts
                - Maximum for at-the-money options
                - Long-dated options have higher vega
                """,
                'Rho': """
                **Rho (œÅ)** measures sensitivity to interest rate changes.
                - Positive for calls, negative for puts
                - Less significant for short-dated options
                - More important for long-dated options
                """
            }
            
            with st.expander(f"‚ÑπÔ∏è About {greek_choice}"):
                st.markdown(interpretations[greek_choice])
        
        elif params['model'] == "Binomial Tree":
            st.info("üå≤ **Note:** Greeks for Binomial Tree are calculated using numerical approximation methods (finite differences)")
            
            # Check if using American options
            is_american = st.session_state.get('bt_is_american', False)
            bt_steps = st.session_state.get('bt_steps', 100)
            
            if is_american:
                st.warning("‚ö†Ô∏è American options - Greeks may show discontinuities due to early exercise boundary")
            
            # Display current Greeks
            greeks = greeks_calc.calculate_all_greeks(
                spot=params['spot'],
                strike=params['strike'],
                time_to_maturity=params['time_to_maturity'],
                risk_free_rate=params['risk_free_rate'],
                volatility=params['volatility'],
                option_type=params['option_type']
            )
            
            st.markdown("### Current Greeks Values")
            display_greeks(greeks)
            
            st.markdown("---")
            
            # Plot all Greeks together
            st.markdown("### Greeks vs Spot Price")
            plot_all_greeks(params, greeks_calc)
            
            st.markdown("---")
            
            # Individual Greek plots
            st.markdown("### Individual Greek Analysis")
            
            greek_choice = st.selectbox(
                "Select Greek to Analyze",
                options=['Delta', 'Gamma', 'Theta', 'Vega', 'Rho'],
                index=0,
                key="bt_greek_choice"
            )
            
            # Map Greek names to calculator methods
            greek_methods = {
                'Delta': greeks_calc.delta,
                'Gamma': greeks_calc.gamma,
                'Theta': greeks_calc.theta,
                'Vega': greeks_calc.vega,
                'Rho': greeks_calc.rho
            }
            
            plot_greeks_vs_spot(
                params=params,
                greek_calculator=greek_methods[greek_choice],
                greek_name=greek_choice
            )
            
            # Greek interpretation
            interpretations = {
                'Delta': """
                **Delta (Œî)** measures the rate of change of option value with respect to changes in the underlying asset's price.
                - **Call Delta**: Ranges from 0 to 1
                - **Put Delta**: Ranges from -1 to 0
                - Also represents the hedge ratio (number of shares to hedge)
                - For American options, may show jumps near early exercise boundary
                """,
                'Gamma': """
                **Gamma (Œì)** measures the rate of change in Delta with respect to changes in the underlying price.
                - Maximum for at-the-money options
                - Indicates Delta stability
                - Same for calls and puts
                - Always positive for long positions
                - Can spike at early exercise boundary for American options
                """,
                'Theta': """
                **Theta (Œò)** measures the rate of change in option value with respect to time (time decay).
                - Usually negative for long positions
                - Expressed per day
                - Maximum for at-the-money options near expiration
                - Time is the enemy of option buyers
                - American options may show different decay patterns
                """,
                'Vega': """
                **Vega (ŒΩ)** measures sensitivity to volatility changes.
                - Always positive for long positions
                - Same for calls and puts
                - Maximum for at-the-money options
                - Long-dated options have higher vega
                """,
                'Rho': """
                **Rho (œÅ)** measures sensitivity to interest rate changes.
                - Positive for calls, negative for puts
                - Less significant for short-dated options
                - More important for long-dated options
                """
            }
            
            with st.expander(f"‚ÑπÔ∏è About {greek_choice}"):
                st.markdown(interpretations[greek_choice])
            
            # Additional info about computation
            with st.expander("üîç Computation Details"):
                st.markdown(f"""
                **Binomial Tree Configuration:**
                - Steps: {bt_steps}
                - Option Type: {'American' if is_american else 'European'}
                - Method: Cox-Ross-Rubinstein (CRR)
                
                **Greek Calculation Method:**
                - All Greeks computed using finite difference approximations
                - Delta: (V(S+Œ¥S) - V(S-Œ¥S)) / (2Œ¥S)
                - Gamma: (V(S+Œ¥S) - 2V(S) + V(S-Œ¥S)) / (Œ¥S¬≤)
                - Similar methods for other Greeks
                
                **Note:** American options may show discontinuities in Greeks near the early exercise boundary.
                """)
        
        else:
            st.info("Greeks analysis is currently available for Black-Scholes, Monte Carlo, and Binomial Tree models.")
    
    # TAB 3: Sensitivity Analysis
    with tab3:
        st.header("üìä Sensitivity Analysis")
        
        if params['model'] == "Black-Scholes":
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìà Price vs Volatility")
                plot_price_vs_volatility(bs_model, params)
                
                st.markdown("""
                **Analysis:**
                - Shows how option value changes with volatility
                - Higher volatility = higher option value
                - Demonstrates Vega sensitivity
                """)
            
            with col2:
                st.subheader("‚è±Ô∏è Price vs Time (Time Decay)")
                plot_price_vs_time(bs_model, params)
                
                st.markdown("""
                **Analysis:**
                - Shows time decay effect (Theta)
                - Options lose value as expiration approaches
                - Decay accelerates near expiration
                """)
            
            st.markdown("---")
            
            # Scenario analysis
            st.subheader("üéØ Scenario Analysis")
            
            st.markdown("Analyze option value under different market scenarios:")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                scenario_spot = st.slider(
                    "Spot Price Change (%)",
                    min_value=-50,
                    max_value=50,
                    value=0,
                    step=5
                )
            
            with col2:
                scenario_vol = st.slider(
                    "Volatility Change (%)",
                    min_value=-50,
                    max_value=50,
                    value=0,
                    step=5
                )
            
            with col3:
                scenario_time = st.slider(
                    "Days Passed",
                    min_value=0,
                    max_value=int(params['time_to_maturity'] * 365),
                    value=0,
                    step=5
                )
            
            # Calculate scenario price
            scenario_params = params.copy()
            scenario_params['spot'] = params['spot'] * (1 + scenario_spot / 100)
            scenario_params['volatility'] = params['volatility'] * (1 + scenario_vol / 100)
            scenario_params['time_to_maturity'] = params['time_to_maturity'] - (scenario_time / 365)
            
            if scenario_params['time_to_maturity'] > 0:
                scenario_price = bs_model.calculate_price(
                    spot=scenario_params['spot'],
                    strike=scenario_params['strike'],
                    time_to_maturity=scenario_params['time_to_maturity'],
                    risk_free_rate=scenario_params['risk_free_rate'],
                    volatility=scenario_params['volatility'],
                    option_type=scenario_params['option_type']
                )
                
                original_price = bs_model.calculate_price(
                    spot=params['spot'],
                    strike=params['strike'],
                    time_to_maturity=params['time_to_maturity'],
                    risk_free_rate=params['risk_free_rate'],
                    volatility=params['volatility'],
                    option_type=params['option_type']
                )
                price_change = scenario_price - original_price
                pct_change = (price_change / original_price) * 100
                
                st.markdown("### Scenario Results")
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric(
                        "Original Price",
                        f"${original_price:.4f}"
                    )
                
                with col2:
                    st.metric(
                        "Scenario Price",
                        f"${scenario_price:.4f}",
                        delta=f"${price_change:.4f}"
                    )
                
                with col3:
                    st.metric(
                        "Change",
                        f"{pct_change:+.2f}%",
                        delta=f"${price_change:.4f}"
                    )
            else:
                st.warning("‚ö†Ô∏è Time to maturity cannot be negative!")
        
        elif params['model'] == "Monte Carlo":
            # Initialize Monte Carlo model
            mc_model = MonteCarloModel(
                num_simulations=50000,  # Reduced for faster sensitivity analysis
                num_steps=252,
                seed=42,
                antithetic=True
            )
            
            st.info("üé≤ Using Monte Carlo simulation (50,000 paths for faster analysis)")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìà Price vs Volatility")
                plot_price_vs_volatility(mc_model, params)
                
                st.markdown("""
                **Analysis:**
                - Shows how option value changes with volatility
                - Higher volatility = higher option value
                - Monte Carlo captures volatility smile effects
                """)
            
            with col2:
                st.subheader("‚è±Ô∏è Price vs Time (Time Decay)")
                plot_price_vs_time(mc_model, params)
                
                st.markdown("""
                **Analysis:**
                - Shows time decay effect (Theta)
                - Options lose value as expiration approaches
                - Stochastic simulation of time evolution
                """)
            
            st.markdown("---")
            
            # Scenario analysis
            st.subheader("üéØ Scenario Analysis")
            
            st.markdown("Analyze option value under different market scenarios:")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                scenario_spot = st.slider(
                    "Spot Price Change (%)",
                    min_value=-50,
                    max_value=50,
                    value=0,
                    step=5,
                    key="mc_scenario_spot"
                )
            
            with col2:
                scenario_vol = st.slider(
                    "Volatility Change (%)",
                    min_value=-50,
                    max_value=50,
                    value=0,
                    step=5,
                    key="mc_scenario_vol"
                )
            
            with col3:
                scenario_days = st.slider(
                    "Days Passed",
                    min_value=0,
                    max_value=int(params['time_to_maturity'] * 365),
                    value=0,
                    step=1,
                    key="mc_scenario_days"
                )
            
            # Calculate scenario
            scenario_params = params.copy()
            scenario_params['spot'] = params['spot'] * (1 + scenario_spot / 100)
            scenario_params['volatility'] = params['volatility'] * (1 + scenario_vol / 100)
            scenario_params['time_to_maturity'] = max(0.001, params['time_to_maturity'] - (scenario_days / 365))
            
            if scenario_params['time_to_maturity'] > 0:
                with st.spinner("Running scenario simulation..."):
                    scenario_price = mc_model.calculate_price(
                        spot=scenario_params['spot'],
                        strike=scenario_params['strike'],
                        time_to_maturity=scenario_params['time_to_maturity'],
                        risk_free_rate=scenario_params['risk_free_rate'],
                        volatility=scenario_params['volatility'],
                        option_type=scenario_params['option_type']
                    )
                    
                    original_price = mc_model.calculate_price(
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type']
                    )
                
                price_change = scenario_price - original_price
                pct_change = (price_change / original_price) * 100
                
                st.markdown("### Scenario Results")
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric(
                        "Original Price (MC)",
                        f"${original_price:.4f}"
                    )
                
                with col2:
                    st.metric(
                        "Scenario Price (MC)",
                        f"${scenario_price:.4f}",
                        delta=f"${price_change:.4f}"
                    )
                
                with col3:
                    st.metric(
                        "Change",
                        f"{pct_change:+.2f}%",
                        delta=f"${price_change:.4f}"
                    )
            else:
                st.warning("‚ö†Ô∏è Time to maturity cannot be negative!")
        
        elif params['model'] == "Binomial Tree":
            # Get settings from session state
            is_american = st.session_state.get('bt_is_american', False)
            bt_steps = st.session_state.get('bt_steps', 100)
            
            # Initialize Binomial Tree model
            bt_model = BinomialTreeModel(
                num_steps=bt_steps,
                american=is_american
            )
            
            st.info(f"üå≤ Using Binomial Tree ({bt_steps} steps, {'American' if is_american else 'European'} option)")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìà Price vs Volatility")
                plot_price_vs_volatility(bt_model, params)
                
                st.markdown("""
                **Analysis:**
                - Shows how option value changes with volatility
                - Higher volatility = higher option value
                - Discrete-time lattice approximation
                """ + ("- American options may show non-linear effects" if is_american else ""))
            
            with col2:
                st.subheader("‚è±Ô∏è Price vs Time (Time Decay)")
                plot_price_vs_time(bt_model, params)
                
                st.markdown("""
                **Analysis:**
                - Shows time decay effect (Theta)
                - Options lose value as expiration approaches
                - Tree structure captures discrete time steps
                """ + ("- American options may show early exercise effects" if is_american else ""))
            
            st.markdown("---")
            
            # Scenario analysis
            st.subheader("üéØ Scenario Analysis")
            
            st.markdown("Analyze option value under different market scenarios:")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                scenario_spot = st.slider(
                    "Spot Price Change (%)",
                    min_value=-50,
                    max_value=50,
                    value=0,
                    step=5,
                    key="bt_scenario_spot"
                )
            
            with col2:
                scenario_vol = st.slider(
                    "Volatility Change (%)",
                    min_value=-50,
                    max_value=50,
                    value=0,
                    step=5,
                    key="bt_scenario_vol"
                )
            
            with col3:
                scenario_days = st.slider(
                    "Days Passed",
                    min_value=0,
                    max_value=int(params['time_to_maturity'] * 365),
                    value=0,
                    step=1,
                    key="bt_scenario_days"
                )
            
            # Calculate scenario
            scenario_params = params.copy()
            scenario_params['spot'] = params['spot'] * (1 + scenario_spot / 100)
            scenario_params['volatility'] = params['volatility'] * (1 + scenario_vol / 100)
            scenario_params['time_to_maturity'] = max(0.001, params['time_to_maturity'] - (scenario_days / 365))
            
            if scenario_params['time_to_maturity'] > 0:
                with st.spinner("Calculating scenario with binomial tree..."):
                    scenario_price = bt_model.calculate_price(
                        spot=scenario_params['spot'],
                        strike=scenario_params['strike'],
                        time_to_maturity=scenario_params['time_to_maturity'],
                        risk_free_rate=scenario_params['risk_free_rate'],
                        volatility=scenario_params['volatility'],
                        option_type=scenario_params['option_type']
                    )
                    
                    original_price = bt_model.calculate_price(
                        spot=params['spot'],
                        strike=params['strike'],
                        time_to_maturity=params['time_to_maturity'],
                        risk_free_rate=params['risk_free_rate'],
                        volatility=params['volatility'],
                        option_type=params['option_type']
                    )
                
                price_change = scenario_price - original_price
                pct_change = (price_change / original_price) * 100
                
                st.markdown("### Scenario Results")
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric(
                        "Original Price (BT)",
                        f"${original_price:.4f}"
                    )
                
                with col2:
                    st.metric(
                        "Scenario Price (BT)",
                        f"${scenario_price:.4f}",
                        delta=f"${price_change:.4f}"
                    )
                
                with col3:
                    st.metric(
                        "Change",
                        f"{pct_change:+.2f}%",
                        delta=f"${price_change:.4f}"
                    )
                
                # Additional info for American options
                if is_american:
                    st.info("üí° **American Option**: Scenario price includes early exercise optionality")
            else:
                st.warning("‚ö†Ô∏è Time to maturity cannot be negative!")
        
        else:
            st.info("Sensitivity analysis is currently available for Black-Scholes, Monte Carlo, and Binomial Tree models.")
    
    # TAB 4: Heatmaps
    with tab4:
        if params['model'] == "Black-Scholes":
            from ui.heatmaps import render_heatmaps_tab
            render_heatmaps_tab(params, bs_model)
        
        elif params['model'] == "Monte Carlo":
            # Initialize Monte Carlo with fewer simulations for heatmaps (performance)
            mc_model = MonteCarloModel(
                num_simulations=30000,  # Reduced for heatmap performance
                num_steps=100,           # Fewer steps for faster computation
                seed=42,
                antithetic=True
            )
            
            st.warning("‚ö†Ô∏è **Note:** Heatmaps use 30,000 simulations for performance. This may take 10-30 seconds to generate.")
            
            from ui.heatmaps import render_heatmaps_tab
            render_heatmaps_tab(params, mc_model)
        
        elif params['model'] == "Binomial Tree":
            # Get settings from session state
            is_american = st.session_state.get('bt_is_american', False)
            bt_steps = st.session_state.get('bt_steps', 100)
            
            # Initialize Binomial Tree with fewer steps for heatmaps (performance)
            bt_model = BinomialTreeModel(
                num_steps=50,  # Reduced steps for faster heatmap generation
                american=is_american
            )
            
            st.warning(f"‚ö†Ô∏è **Note:** Heatmaps use 50 steps for performance (vs {bt_steps} in pricing). {'American options' if is_american else 'European options'} selected. This may take 10-20 seconds to generate.")
            
            from ui.heatmaps import render_heatmaps_tab
            render_heatmaps_tab(params, bt_model)
        
        else:
            st.info("Heatmaps are currently available for Black-Scholes, Monte Carlo, and Binomial Tree models.")
    
    # TAB 5: About
    with tab5:
        render_about_page()


def render_about_page():
    """Render the About page with project and developer information."""
    
    st.markdown("""
    <div style='text-align: center; padding: 20px 0;'>
        <h1>üöÄ Option Pricing Calculator</h1>
        <p style='font-size: 18px; color: #666;'>Advanced Financial Derivatives Pricing Models</p>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown("""
        ## üìã About This Project
        
        This web application implements advanced mathematical models for pricing financial options,
        providing a professional tool for financial analysts, traders, and quantitative finance students.
        
        ### üî¨ Models Implemented
        
        **1. Black-Scholes Model** ‚úÖ **FULLY OPERATIONAL**
        - Classic analytical solution for European options
        - Closed-form formula for fast and accurate pricing
        - Ideal for vanilla options
        - All features available: Greeks, Sensitivity, Heatmaps
        
        **2. Monte Carlo Simulation** ‚úÖ **FULLY OPERATIONAL**
        - Stochastic simulation using geometric Brownian motion
        - 100,000 simulations with antithetic variates
        - Confidence intervals and statistical analysis
        - All features available: Greeks, Sensitivity, Heatmaps
        - Handles path-dependent and exotic options
        
        **3. Binomial Tree Model** ‚úÖ **FULLY OPERATIONAL**
        - Cox-Ross-Rubinstein discrete-time lattice model
        - Supports both European and American options
        - Configurable time steps (10-500)
        - Early exercise detection and premium calculation
        - Convergence analysis to Black-Scholes
        - All features available: Greeks, Sensitivity, Heatmaps
        
        ### ‚ú® Key Features
        
        - üîÑ **Real-time pricing** calculations
        - üìä **Complete Greeks analysis** (Delta, Gamma, Theta, Vega, Rho)
        - üìà **Interactive charts** with Plotly
        - üîç **Advanced sensitivity analysis**
        - ‚öñÔ∏è **Model comparison** capabilities
        - üéØ **Profit/Loss diagrams**
        - üì± **Responsive interface** and user-friendly
        
        ### üõ†Ô∏è Technology Stack
        
        - **Python** - Core programming language
        - **Streamlit** - Web application framework
        - **NumPy & SciPy** - Mathematical computations
        - **Plotly** - Interactive data visualizations
        - **Pandas** - Data manipulation
        - **Object-Oriented Design** - Scalable architecture
        
        ### üéØ Use Cases
        
        - **Financial Analysts** - Professional derivatives valuation
        - **Quantitative Traders** - Rapid pricing and Greeks analysis
        - **Risk Managers** - Sensitivity calculations for hedging
        - **Students** - Practical learning of financial models
        - **Researchers** - Comparison between methodologies
        """)
    
    with col2:
        st.markdown("""
        <div style='background-color: #f0f2f6; padding: 20px; border-radius: 10px; margin-bottom: 20px;'>
            <h3 style='color: #1f77b4; margin-top: 0;'>üë®‚Äçüíª Developer</h3>
            <h4 style='margin: 10px 0;'>Giovanni Destasio</h4>
            <p style='color: #666; font-style: italic;'>Financial Engineer & Quantitative Developer</p>
        </div>
        """, unsafe_allow_html=True)
        
        st.markdown("""
        ### üéì Background
        Specialized in:
        - **Derivatives Pricing & Valuation**
        - **Risk Management & Analytics**  
        - **Quantitative Finance Modeling**
        - **Python/R Financial Programming**
        - **Machine Learning in Finance**
        
        ### üíº Experience
        - Financial modeling for banking institutions
        - Risk management systems development
        - Trading algorithm implementation
        - Computational finance research
        
        ### üîó Contact & Links
        """)
        
        # Contact buttons
        col_email, col_linkedin = st.columns(2)
        with col_email:
            st.link_button("üìß Email", "mailto:giovanni.destasio@example.com", use_container_width=True)
        with col_linkedin:
            st.link_button("üíº LinkedIn", "https://linkedin.com/in/giovanni-destasio", use_container_width=True)
        
        st.link_button("üêô GitHub Profile", "https://github.com/giovannidestasio", use_container_width=True)
        st.link_button("üìä Project Repository", "https://github.com/giovannidestasio/option-pricer", use_container_width=True)
    
    st.markdown("---")
    
    st.markdown("""
    <div style='text-align: center; color: #666;'>
        <p><em>Built with ‚ù§Ô∏è for the quantitative finance community</em></p>
        <p><strong>¬© 2024 Giovanni Destasio - Option Pricing Calculator</strong></p>
        <p>Version 1.0.0</p>
    </div>
    """, unsafe_allow_html=True)


if __name__ == "__main__":
    main()
